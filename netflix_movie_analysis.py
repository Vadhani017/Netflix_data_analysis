# -*- coding: utf-8 -*-
"""Netflix_movie_analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H-IKxzYFXM3j8m6esLHmiHY8w1xQXMBE
"""

pip install implicit

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from implicit.als import AlternatingLeastSquares
from scipy.sparse import csr_matrix

netflix_data = pd.read_csv("/content/netflix_titles.csv")

content_type_distribution = netflix_data['type'].value_counts()

country_distribution = netflix_data['country'].value_counts().head(10)

netflix_data.head(5)



# Set the style
plt.style.use('ggplot')

# Plot 1: Distribution of Content Types
plt.figure(figsize=(8, 6))
content_type_distribution.plot(kind='bar', color=['skyblue', 'salmon'])
plt.title('Distribution of Content Types')
plt.xlabel('Content Type')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()
content_type_distribution

netflix_data['listed_in'] = netflix_data['listed_in'].str.split(', ')
all_genres = [genre for sublist in netflix_data['listed_in'].dropna() for genre in sublist]
top_genres = pd.Series(all_genres).value_counts().head(10)

# Plot 2: Top 10 Genres
plt.figure(figsize=(12, 6))
top_genres.plot(kind='bar', color='skyblue')
plt.title('Top 10 Genres')
plt.xlabel('Genre')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()
top_genres

top_directors = netflix_data['director'].value_counts().head(10)
netflix_data['cast'] = netflix_data['cast'].str.split(', ')
all_cast = [actor for sublist in netflix_data['cast'].dropna() for actor in sublist]
top_cast_members = pd.Series(all_cast).value_counts().head(10)

# Plot 3: Most Frequent Directors
plt.figure(figsize=(12, 6))
top_directors.plot(kind='bar', color='salmon')
plt.title('Top 10 Directors')
plt.xlabel('Director')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()
top_directors

# Plot 4: Most Frequent Cast Members
plt.figure(figsize=(12, 6))
top_cast_members.plot(kind='bar', color='skyblue')
plt.title('Top 10 Cast Members')
plt.xlabel('Cast Member')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()
top_cast_members

# Plot 5: Country Distribution
plt.figure(figsize=(12, 6))
country_distribution.plot(kind='bar', color='salmon')
plt.title('Top 10 Countries Producing Content')
plt.xlabel('Country')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()
country_distribution

release_year_trends = netflix_data['release_year'].value_counts().sort_index()

# Plot 6: Release Year Trends
plt.figure(figsize=(14, 8))
release_year_trends.plot(kind='line', marker='o', color='skyblue')
plt.title('Release Year Trends')
plt.xlabel('Year')
plt.ylabel('Number of Releases')
plt.grid(True)
plt.show()
release_year_trends

age_ratings_distribution = netflix_data['rating'].value_counts()

# Plot 7: Age Ratings Distribution
plt.figure(figsize=(12, 6))
age_ratings_distribution.plot(kind='bar', color='salmon')
plt.title('Age Ratings Distribution')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

from datetime import datetime

# Assuming netflix_data is a DataFrame with a column named "date_added"
date_strings = netflix_data["date_added"]
format_string = "%B %d, %Y"

parsed_dates = []

for date_string in date_strings:
    if isinstance(date_string, str):
        try:
            parsed_date = datetime.strptime(date_string, format_string)
            parsed_dates.append(parsed_date)
        except ValueError:
            parsed_dates.append(None)  # or any other handling for invalid dates
    else:
        parsed_dates.append(None)  # or any other handling for non-string values

netflix_data["date_added"] = parsed_dates

# Additional Analysis
import warnings
warnings.filterwarnings('ignore')

# 1. Distribution of Movie Durations
# Filter out movies and extract durations in minutes
movies_data = netflix_data[netflix_data['type'] == 'Movie']
movies_data['duration'] = movies_data['duration'].str.replace(' min', '').astype(float)

# 2. Monthly Additions of Titles Over the Years
# Convert date_added to datetime
netflix_data['date_added'] = pd.to_datetime(netflix_data['date_added'])
# Extract year and month
netflix_data['year_added'] = netflix_data['date_added'].dt.year
netflix_data['month_added'] = netflix_data['date_added'].dt.month
# Group by year and month
monthly_additions = netflix_data.groupby(['year_added', 'month_added']).size().unstack(fill_value=0)

# 3. Top Rated Titles by Genre
# Let's assume we have a column 'user_rating' in our dataset for this analysis (since it is not in the given dataset)
# For the purpose of the example, we'll generate a random 'user_rating' for the dataset
import numpy as np
np.random.seed(42)
netflix_data['user_rating'] = np.random.uniform(1, 5, netflix_data.shape[0])

# Get the mean rating for each genre
genre_ratings = netflix_data.explode('listed_in').groupby('listed_in')['user_rating'].mean().sort_values(ascending=False).head(10)

# Plotting the results

# Plot 1: Distribution of Movie Durations
plt.figure(figsize=(8, 6))
plt.hist(movies_data['duration'].dropna(), bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Movie Durations')
plt.xlabel('Duration (minutes)')
plt.ylabel('Number of Movies')
plt.show()

# Plot 2: Monthly Additions of Titles Over the Years
plt.figure(figsize=(8, 8))
monthly_additions.T.plot(kind='bar', stacked=True, figsize=(14, 8), colormap='coolwarm')
plt.title('Monthly Additions of Titles Over the Years')
plt.xlabel('Month')
plt.ylabel('Number of Titles Added')
plt.legend(title='Year', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

# Plot 3: Top Rated Titles by Genre
plt.figure(figsize=(8, 6))
genre_ratings.plot(kind='bar', color='salmon')
plt.title('Top Rated Titles by Genre')
plt.xlabel('Genre')
plt.ylabel('Average User Rating')
plt.xticks(rotation=45)
plt.show()

missing_values = netflix_data.isna().sum()
print("Missing values in each column:\n", missing_values)

netflix_data = netflix_data.dropna()

netflix_data.count()

netflix_data.head(10)

# Assuming the column containing show IDs is named 'show_id_column'
netflix_data['show_id'] = netflix_data['show_id'].str.replace('s', '').astype(int)

# Convert lists in the 'listed_in' column to strings
netflix_data['listed_in'] = netflix_data['listed_in'].apply(lambda x: ', '.join(x) if isinstance(x, list) else x)

# Concatenate description and listed_in columns
netflix_data['combined_features'] = netflix_data['description'] + ' ' + netflix_data['listed_in']

# Initialize TF-IDF vectorizer
tfidf_vectorizer = TfidfVectorizer(stop_words='english')

# Fit and transform the combined features
tfidf_matrix = tfidf_vectorizer.fit_transform(netflix_data['combined_features'])

# Convert to sparse matrix
sparse_matrix = csr_matrix(tfidf_matrix)

# Train the ALS model
model = AlternatingLeastSquares(factors=10, regularization=0.1, iterations=50)
model.fit(sparse_matrix.T)

# Get the user input for the title
user_title = input("Enter the title of the show: ")

# Find the show_id corresponding to the input title
matched_show = netflix_data[netflix_data['title'] == user_title]
if len(matched_show) == 0:
    print("Show not found.")
else:
    show_id = matched_show.iloc[0]['show_id']
    recommendations = model.similar_items(int(show_id))  # Convert show_id to integer
    indices, scores = recommendations

    # Get the recommended show_ids
    recommended_show_ids = netflix_data.iloc[indices]['show_id'].values

    # Get the corresponding information for each recommended show
    recommended_info = netflix_data.iloc[indices][['show_id', 'type', 'title', 'description']]

    # Combine the recommended show_ids and their corresponding information
    recommended_info['similarity_score'] = scores
    recommended_info['recommended_show_id'] = recommended_show_ids

    # Display the recommendations with selected columns
    print(recommended_info[['recommended_show_id', 'type', 'title', 'description']])

